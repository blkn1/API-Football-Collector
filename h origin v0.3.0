[1mdiff --git a/config/jobs/daily.yaml b/config/jobs/daily.yaml[m
[1mindex 00cf0c7..89f0254 100644[m
[1m--- a/config/jobs/daily.yaml[m
[1m+++ b/config/jobs/daily.yaml[m
[36m@@ -3,7 +3,7 @@[m [mjobs:[m
   # Enable and fill params according to your tracked leagues/seasons.[m
   - job_id: "daily_standings"[m
     type: "incremental_daily"[m
[31m-    enabled: false[m
[32m+[m[32m    enabled: true[m
     priority: "HIGH"[m
     endpoint: "/standings"[m
     params:[m
[36m@@ -25,7 +25,7 @@[m [mjobs:[m
 [m
   - job_id: "daily_fixtures_by_date"[m
     type: "incremental_daily"[m
[31m-    enabled: false[m
[32m+[m[32m    enabled: true[m
     priority: "HIGH"[m
     endpoint: "/fixtures"[m
     params:[m
[36m@@ -34,6 +34,57 @@[m [mjobs:[m
       type: "cron"[m
       cron: "0 * * * *"  # Hourly[m
     target_layer: "raw+core+mart"[m
[32m+[m[32m  - job_id: "injuries_hourly"[m
[32m+[m[32m    type: "incremental_daily"[m
[32m+[m[32m    enabled: true[m
[32m+[m[32m    priority: "HIGH"[m
[32m+[m[32m    endpoint: "/injuries"[m
[32m+[m[32m    params: {}[m
[32m+[m[32m    interval:[m
[32m+[m[32m      type: "cron"[m
[32m+[m[32m      cron: "0 * * * *"  # Hourly (interpreted in SCHEDULER_TIMEZONE)[m
[32m+[m[32m    target_layer: "raw+core"[m
[32m+[m[32m    dependencies:[m
[32m+[m[32m      - "bootstrap_leagues"[m
[32m+[m[32m      - "bootstrap_teams"[m
[32m+[m[32m    coverage_target:[m
[32m+[m[32m      endpoint: "/injuries"[m
[32m+[m[32m      min_records: 1[m
[32m+[m[32m      max_lag_minutes: 120[m
[32m+[m
[32m+[m[32m  - job_id: "fixture_details_recent_finalize"[m
[32m+[m[32m    type: "incremental_daily"[m
[32m+[m[32m    enabled: true[m
[32m+[m[32m    priority: "HIGH"[m
[32m+[m[32m    endpoint: "/fixtures/*"[m
[32m+[m[32m    params: {}[m
[32m+[m[32m    interval:[m
[32m+[m[32m      type: "cron"[m
[32m+[m[32m      cron: "*/15 * * * *"  # Every 15 minutes (for lineup window + last-24h finalization)[m
[32m+[m[32m    target_layer: "raw+core"[m
[32m+[m[32m    dependencies:[m
[32m+[m[32m      - "daily_fixtures_by_date"[m
[32m+[m[32m    coverage_target:[m
[32m+[m[32m      endpoint: "/fixtures/details"[m
[32m+[m[32m      min_records: 1[m
[32m+[m[32m      max_lag_minutes: 240[m
[32m+[m
[32m+[m[32m  - job_id: "fixture_details_backfill_90d"[m
[32m+[m[32m    type: "incremental_daily"[m
[32m+[m[32m    enabled: false  # Enable after observing quota trends (rolling 90d backfill can be expensive).[m
[32m+[m[32m    priority: "MEDIUM"[m
[32m+[m[32m    endpoint: "/fixtures/*"[m
[32m+[m[32m    params: {}[m
[32m+[m[32m    interval:[m
[32m+[m[32m      type: "cron"[m
[32m+[m[32m      cron: "*/10 * * * *"  # Every 10 minutes, bounded by FIXTURE_DETAILS_BACKFILL_BATCH[m
[32m+[m[32m    target_layer: "raw+core"[m
[32m+[m[32m    dependencies:[m
[32m+[m[32m      - "daily_fixtures_by_date"[m
[32m+[m[32m    coverage_target:[m
[32m+[m[32m      endpoint: "/fixtures/details_backfill_90d"[m
[32m+[m[32m      min_records: 1[m
[32m+[m[32m      max_lag_minutes: 1440[m
     dependencies:[m
       - "bootstrap_leagues"[m
       - "bootstrap_teams"[m
[1mdiff --git a/scripts/apply_schemas.py b/scripts/apply_schemas.py[m
[1mindex 013fc97..7cb1a66 100644[m
[1m--- a/scripts/apply_schemas.py[m
[1m+++ b/scripts/apply_schemas.py[m
[36m@@ -81,11 +81,11 @@[m [mdef main() -> int:[m
     if not schemas_dir.exists():[m
         raise SystemExit(f"schemas_dir_missing:{schemas_dir}")[m
 [m
[31m-    # Apply in a deterministic order and avoid psql meta-commands (\i) in 00_init.sql.[m
[32m+[m[32m    # Apply base schemas in a deterministic order and avoid psql meta-commands (\i) in 00_init.sql.[m
     # raw.sql must run before mart.sql (mart depends on raw.api_responses).[m
[31m-    ordered = ["raw.sql", "core.sql", "mart.sql"][m
[31m-    sql_files = [schemas_dir / name for name in ordered if (schemas_dir / name).exists()][m
[31m-    if not sql_files:[m
[32m+[m[32m    base = ["raw.sql", "core.sql", "mart.sql"][m
[32m+[m[32m    base_files = [schemas_dir / name for name in base if (schemas_dir / name).exists()][m
[32m+[m[32m    if not base_files:[m
         raise SystemExit(f"no_sql_files_found:{schemas_dir}")[m
 [m
     # Ensure DB exists before attempting to connect/apply schemas.[m
[36m@@ -95,18 +95,35 @@[m [mdef main() -> int:[m
     try:[m
         conn.autocommit = True[m
         with conn.cursor() as cur:[m
[31m-            if _schemas_already_applied(cur):[m
[31m-                print("[OK] schemas already applied (skipping)")[m
[31m-                return 0[m
[31m-            for p in sql_files:[m
[32m+[m[32m            base_applied = _schemas_already_applied(cur)[m
[32m+[m
[32m+[m[32m            # Always apply extension/migration files (idempotent). This allows schema evolution without[m
[32m+[m[32m            # re-running trigger-heavy core.sql on every startup.[m
[32m+[m[32m            extras = sorted([m
[32m+[m[32m                [[m
[32m+[m[32m                    p[m
[32m+[m[32m                    for p in schemas_dir.glob("*.sql")[m
[32m+[m[32m                    if p.name not in set(base + ["00_init.sql"])[m
[32m+[m[32m                ][m
[32m+[m[32m            )[m
[32m+[m
[32m+[m[32m            if not base_applied:[m
[32m+[m[32m                for p in base_files:[m
[32m+[m[32m                    sql_text = p.read_text(encoding="utf-8")[m
[32m+[m[32m                    try:[m
[32m+[m[32m                        cur.execute(sql_text)[m
[32m+[m[32m                        print(f"[OK] applied {p.name}")[m
[32m+[m[32m                    except pg_errors.DuplicateObject:[m
[32m+[m[32m                        # Triggers already exist -> safe to continue.[m
[32m+[m[32m                        print(f"[OK] base already present (duplicate objects while applying {p.name}); continuing")[m
[32m+[m
[32m+[m[32m            for p in extras:[m
                 sql_text = p.read_text(encoding="utf-8")[m
                 try:[m
                     cur.execute(sql_text)[m
                     print(f"[OK] applied {p.name}")[m
                 except pg_errors.DuplicateObject:[m
[31m-                    # Most common case: triggers already exist. Treat as already applied and exit cleanly.[m
[31m-                    print(f"[OK] schema already present (duplicate objects while applying {p.name}); skipping")[m
[31m-                    return 0[m
[32m+[m[32m                    print(f"[OK] already present (duplicate objects while applying {p.name}); continuing")[m
     finally:[m
         conn.close()[m
     return 0[m
[1mdiff --git a/scripts/daily_sync.py b/scripts/daily_sync.py[m
[1mindex 00d3729..4ab661b 100644[m
[1m--- a/scripts/daily_sync.py[m
[1m+++ b/scripts/daily_sync.py[m
[36m@@ -2,6 +2,7 @@[m [mfrom __future__ import annotations[m
 [m
 import argparse[m
 import asyncio[m
[32m+[m[32mimport os[m
 import sys[m
 from dataclasses import dataclass[m
 from datetime import datetime, timezone[m
[36m@@ -249,13 +250,13 @@[m [masync def sync_daily_fixtures([m
                 if max_venues <= 0:[m
                     upserted_venues = 0[m
                 else:[m
[31m-                upserted_venues = await backfill_missing_venues_for_fixtures([m
[31m-                    venue_ids=venue_ids,[m
[31m-                    client=client2,[m
[31m-                    limiter=limiter2,[m
[31m-                    dry_run=False,[m
[32m+[m[32m                    upserted_venues = await backfill_missing_venues_for_fixtures([m
[32m+[m[32m                        venue_ids=venue_ids,[m
[32m+[m[32m                        client=client2,[m
[32m+[m[32m                        limiter=limiter2,[m
[32m+[m[32m                        dry_run=False,[m
                         max_to_fetch=max_venues,[m
[31m-                )[m
[32m+[m[32m                    )[m
                 if upserted_venues:[m
                     logger.info("venues_backfilled", league_id=league_id, upserted=upserted_venues)[m
             except Exception as e:[m
[1mdiff --git a/src/collector/scheduler.py b/src/collector/scheduler.py[m
[1mindex 9c160ab..d81df03 100644[m
[1m--- a/src/collector/scheduler.py[m
[1m+++ b/src/collector/scheduler.py[m
[36m@@ -17,6 +17,11 @@[m [mfrom zoneinfo import ZoneInfo[m
 from src.collector.api_client import APIClient[m
 from src.collector.rate_limiter import EmergencyStopError, RateLimiter[m
 from src.jobs.incremental_daily import run_daily_fixtures_by_date, run_daily_standings[m
[32m+[m[32mfrom src.jobs.injuries import run_injuries_hourly[m
[32m+[m[32mfrom src.jobs.fixture_details import ([m
[32m+[m[32m    run_fixture_details_backfill_90d,[m
[32m+[m[32m    run_fixture_details_recent_finalize,[m
[32m+[m[32m)[m
 from src.jobs.static_bootstrap import ([m
     run_bootstrap_countries,[m
     run_bootstrap_leagues,[m
[36m@@ -136,7 +141,7 @@[m [mdef _build_runner([m
 [m
     Supported:[m
     - static_bootstrap: bootstrap_timezones, bootstrap_countries, bootstrap_leagues, bootstrap_teams[m
[31m-    - incremental_daily: daily_fixtures_by_date, daily_standings[m
[32m+[m[32m    - incremental_daily: daily_fixtures_by_date, daily_standings, injuries_hourly, fixture_details_recent_finalize, fixture_details_backfill_90d[m
     """[m
 [m
     async def _run() -> None:[m
[36m@@ -177,6 +182,16 @@[m [mdef _build_runner([m
                     limiter=limiter,[m
                     config_path=_project_root() / "config" / "jobs" / "daily.yaml",[m
                 )[m
[32m+[m[32m            elif job.job_id == "injuries_hourly":[m
[32m+[m[32m                await run_injuries_hourly([m
[32m+[m[32m                    client=client,[m
[32m+[m[32m                    limiter=limiter,[m
[32m+[m[32m                    config_path=_project_root() / "config" / "jobs" / "daily.yaml",[m
[32m+[m[32m                )[m
[32m+[m[32m            elif job.job_id == "fixture_details_recent_finalize":[m
[32m+[m[32m                await run_fixture_details_recent_finalize(client=client, limiter=limiter)[m
[32m+[m[32m            elif job.job_id == "fixture_details_backfill_90d":[m
[32m+[m[32m                await run_fixture_details_backfill_90d(client=client, limiter=limiter)[m
             else:[m
                 raise ValueError(f"Unknown incremental_daily job_id: {job.job_id}")[m
         else:[m
[1mdiff --git a/src/coverage/calculator.py b/src/coverage/calculator.py[m
[1mindex 7f2eb40..34c4359 100644[m
[1m--- a/src/coverage/calculator.py[m
[1m+++ b/src/coverage/calculator.py[m
[36m@@ -7,7 +7,12 @@[m [mfrom typing import Any[m
 [m
 import yaml[m
 [m
[31m-from utils.db import query_scalar[m
[32m+[m[32mtry:[m
[32m+[m[32m    # scripts/ context (adds /src to sys.path)[m
[32m+[m[32m    from utils.db import query_scalar  # type: ignore[m
[32m+[m[32mexcept Exception:  # pragma: no cover[m
[32m+[m[32m    # src/ package context[m
[32m+[m[32m    from src.utils.db import query_scalar  # type: ignore[m
 [m
 [m
 @dataclass(frozen=True)[m
[36m@@ -87,6 +92,187 @@[m [mclass CoverageCalculator:[m
             "overall_coverage": round(overall, 2),[m
         }[m
 [m
[32m+[m[32m    def calculate_injuries_coverage(self, league_id: int, season: int) -> dict[str, Any]:[m
[32m+[m[32m        """[m
[32m+[m[32m        Coverage for /injuries (current-only):[m
[32m+[m[32m        - expected_count = 1 (we only need "present + fresh")[m
[32m+[m[32m        - actual_count = 1 if we have any injuries rows for league+season, else 0[m
[32m+[m[32m        """[m
[32m+[m[32m        core_total = int([m
[32m+[m[32m            query_scalar([m
[32m+[m[32m                "SELECT COUNT(*) FROM core.injuries WHERE league_id = %s AND season = %s",[m
[32m+[m[32m                (int(league_id), int(season)),[m
[32m+[m[32m            )[m
[32m+[m[32m            or 0[m
[32m+[m[32m        )[m
[32m+[m[32m        actual = 1 if core_total > 0 else 0[m
[32m+[m[32m        expected = 1[m
[32m+[m[32m        count_cov = 100.0 if actual >= expected else 0.0[m
[32m+[m
[32m+[m[32m        last_update = self._query_last_update_generic([m
[32m+[m[32m            table="core.injuries",[m
[32m+[m[32m            where="league_id = %s AND season = %s",[m
[32m+[m[32m            params=(int(league_id), int(season)),[m
[32m+[m[32m        )[m
[32m+[m[32m        lag_minutes = self._calculate_lag_minutes(last_update)[m
[32m+[m[32m        max_lag = int(self.config.max_lag_minutes_daily)[m
[32m+[m[32m        freshness_cov = max(0.0, 100.0 - (lag_minutes / max_lag * 100.0)) if max_lag > 0 else 0.0[m
[32m+[m
[32m+[m[32m        raw_count = int([m
[32m+[m[32m            query_scalar([m
[32m+[m[32m                """[m
[32m+[m[32m                SELECT COUNT(*)[m
[32m+[m[32m                FROM raw.api_responses[m
[32m+[m[32m                WHERE endpoint = '/injuries'[m
[32m+[m[32m                  AND fetched_at > NOW() - INTERVAL '24 hours'[m
[32m+[m[32m                  AND requested_params->>'league' = %s[m
[32m+[m[32m                  AND requested_params->>'season' = %s[m
[32m+[m[32m                """,[m
[32m+[m[32m                (str(int(league_id)), str(int(season))),[m
[32m+[m[32m            )[m
[32m+[m[32m            or 0[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        # For injuries, "pipeline" is best represented as freshness/presence (counts aren't comparable to RAW envelopes).[m
[32m+[m[32m        pipeline_cov = 100.0 if raw_count > 0 and core_total >= 0 else 0.0[m
[32m+[m
[32m+[m[32m        w = self.config.weights[m
[32m+[m[32m        overall = ([m
[32m+[m[32m            count_cov * float(w["count_coverage"])[m
[32m+[m[32m            + freshness_cov * float(w["freshness_coverage"])[m
[32m+[m[32m            + pipeline_cov * float(w["pipeline_coverage"])[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        last_update_iso = last_update.isoformat().replace("+00:00", "Z") if last_update else None[m
[32m+[m[32m        return {[m
[32m+[m[32m            "league_id": int(league_id),[m
[32m+[m[32m            "league_name": self._query_league_name(league_id),[m
[32m+[m[32m            "season": int(season),[m
[32m+[m[32m            "endpoint": "/injuries",[m
[32m+[m[32m            "expected_count": expected,[m
[32m+[m[32m            "actual_count": actual,[m
[32m+[m[32m            "count_coverage": round(count_cov, 2),[m
[32m+[m[32m            "last_update": last_update_iso,[m
[32m+[m[32m            "lag_minutes": int(lag_minutes),[m
[32m+[m[32m            "freshness_coverage": round(freshness_cov, 2),[m
[32m+[m[32m            "raw_count": raw_count,[m
[32m+[m[32m            "core_count": core_total,[m
[32m+[m[32m            "pipeline_coverage": round(pipeline_cov, 2),[m
[32m+[m[32m            "overall_coverage": round(overall, 2),[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m    def calculate_fixture_endpoint_coverage([m
[32m+[m[32m        self,[m
[32m+[m[32m        *,[m
[32m+[m[32m        league_id: int,[m
[32m+[m[32m        season: int,[m
[32m+[m[32m        endpoint: str,[m
[32m+[m[32m        core_table: str,[m
[32m+[m[32m        days: int = 90,[m
[32m+[m[32m    ) -> dict[str, Any]:[m
[32m+[m[32m        """[m
[32m+[m[32m        Coverage for per-fixture endpoints (players/events/statistics/lineups) over a rolling window.[m
[32m+[m[32m        - expected_count = completed fixtures in last N days[m
[32m+[m[32m        - actual_count   = distinct fixtures with RAW call for endpoint in last N days[m
[32m+[m[32m        - pipeline_cov   = distinct fixtures with CORE rows / distinct fixtures with RAW call[m
[32m+[m[32m        """[m
[32m+[m[32m        expected = int([m
[32m+[m[32m            query_scalar([m
[32m+[m[32m                """[m
[32m+[m[32m                SELECT COUNT(*)[m
[32m+[m[32m                FROM core.fixtures[m
[32m+[m[32m                WHERE league_id = %s AND season = %s[m
[32m+[m[32m                  AND date >= NOW() - (%s::text || ' days')::interval[m
[32m+[m[32m                  AND status_short = ANY(ARRAY['FT','AET','PEN'])[m
[32m+[m[32m                """,[m
[32m+[m[32m                (int(league_id), int(season), int(days)),[m
[32m+[m[32m            )[m
[32m+[m[32m            or 0[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        raw_fixtures = int([m
[32m+[m[32m            query_scalar([m
[32m+[m[32m                """[m
[32m+[m[32m                SELECT COUNT(DISTINCT f.id)[m
[32m+[m[32m                FROM raw.api_responses r[m
[32m+[m[32m                JOIN core.fixtures f ON f.id = (r.requested_params->>'fixture')::bigint[m
[32m+[m[32m                WHERE r.endpoint = %s[m
[32m+[m[32m                  AND f.league_id = %s[m
[32m+[m[32m                  AND f.season = %s[m
[32m+[m[32m                  AND f.date >= NOW() - (%s::text || ' days')::interval[m
[32m+[m[32m                  AND f.status_short = ANY(ARRAY['FT','AET','PEN'])[m
[32m+[m[32m                """,[m
[32m+[m[32m                (str(endpoint), int(league_id), int(season), int(days)),[m
[32m+[m[32m            )[m
[32m+[m[32m            or 0[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        core_fixtures = int([m
[32m+[m[32m            query_scalar([m
[32m+[m[32m                f"""[m
[32m+[m[32m                SELECT COUNT(DISTINCT t.fixture_id)[m
[32m+[m[32m                FROM {core_table} t[m
[32m+[m[32m                JOIN core.fixtures f ON f.id = t.fixture_id[m
[32m+[m[32m                WHERE f.league_id = %s[m
[32m+[m[32m                  AND f.season = %s[m
[32m+[m[32m                  AND f.date >= NOW() - (%s::text || ' days')::interval[m
[32m+[m[32m                  AND f.status_short = ANY(ARRAY['FT','AET','PEN'])[m
[32m+[m[32m                """,[m
[32m+[m[32m                (int(league_id), int(season), int(days)),[m
[32m+[m[32m            )[m
[32m+[m[32m            or 0[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        count_cov = (raw_fixtures / expected * 100.0) if expected > 0 else 0.0[m
[32m+[m
[32m+[m[32m        last_update = self._query_last_raw_endpoint_update_joined(endpoint=endpoint, league_id=league_id, season=season)[m
[32m+[m[32m        lag_minutes = self._calculate_lag_minutes(last_update)[m
[32m+[m[32m        max_lag = int(self.config.max_lag_minutes_daily)[m
[32m+[m[32m        freshness_cov = max(0.0, 100.0 - (lag_minutes / max_lag * 100.0)) if max_lag > 0 else 0.0[m
[32m+[m
[32m+[m[32m        raw_count_24h = int([m
[32m+[m[32m            query_scalar([m
[32m+[m[32m                """[m
[32m+[m[32m                SELECT COUNT(*)[m
[32m+[m[32m                FROM raw.api_responses r[m
[32m+[m[32m                JOIN core.fixtures f ON f.id = (r.requested_params->>'fixture')::bigint[m
[32m+[m[32m                WHERE r.endpoint = %s[m
[32m+[m[32m                  AND r.fetched_at > NOW() - INTERVAL '24 hours'[m
[32m+[m[32m                  AND f.league_id = %s[m
[32m+[m[32m                  AND f.season = %s[m
[32m+[m[32m                """,[m
[32m+[m[32m                (str(endpoint), int(league_id), int(season)),[m
[32m+[m[32m            )[m
[32m+[m[32m            or 0[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        pipeline_cov = (core_fixtures / raw_fixtures * 100.0) if raw_fixtures > 0 else 0.0[m
[32m+[m
[32m+[m[32m        w = self.config.weights[m
[32m+[m[32m        overall = ([m
[32m+[m[32m            count_cov * float(w["count_coverage"])[m
[32m+[m[32m            + freshness_cov * float(w["freshness_coverage"])[m
[32m+[m[32m            + pipeline_cov * float(w["pipeline_coverage"])[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        last_update_iso = last_update.isoformat().replace("+00:00", "Z") if last_update else None[m
[32m+[m[32m        return {[m
[32m+[m[32m            "league_id": int(league_id),[m
[32m+[m[32m            "league_name": self._query_league_name(league_id),[m
[32m+[m[32m            "season": int(season),[m
[32m+[m[32m            "endpoint": str(endpoint),[m
[32m+[m[32m            "expected_count": expected,[m
[32m+[m[32m            "actual_count": raw_fixtures,[m
[32m+[m[32m            "count_coverage": round(count_cov, 2),[m
[32m+[m[32m            "last_update": last_update_iso,[m
[32m+[m[32m            "lag_minutes": int(lag_minutes),[m
[32m+[m[32m            "freshness_coverage": round(freshness_cov, 2),[m
[32m+[m[32m            "raw_count": raw_count_24h,[m
[32m+[m[32m            "core_count": core_fixtures,[m
[32m+[m[32m            "pipeline_coverage": round(pipeline_cov, 2),[m
[32m+[m[32m            "overall_coverage": round(overall, 2),[m
[32m+[m[32m        }[m
[32m+[m
     def _query_actual_fixtures(self, league_id: int, season: int) -> int:[m
         return int([m
             query_scalar([m
[36m@@ -108,6 +294,32 @@[m [mclass CoverageCalculator:[m
             return v.astimezone(timezone.utc)[m
         return None[m
 [m
[32m+[m[32m    def _query_last_update_generic(self, *, table: str, where: str, params: tuple[Any, ...]) -> datetime | None:[m
[32m+[m[32m        v = query_scalar(f"SELECT MAX(updated_at) FROM {table} WHERE {where}", params)[m
[32m+[m[32m        if isinstance(v, datetime):[m
[32m+[m[32m            if v.tzinfo is None:[m
[32m+[m[32m                return v.replace(tzinfo=timezone.utc)[m
[32m+[m[32m            return v.astimezone(timezone.utc)[m
[32m+[m[32m        return None[m
[32m+[m
[32m+[m[32m    def _query_last_raw_endpoint_update_joined(self, *, endpoint: str, league_id: int, season: int) -> datetime | None:[m
[32m+[m[32m        v = query_scalar([m
[32m+[m[32m            """[m
[32m+[m[32m            SELECT MAX(r.fetched_at)[m
[32m+[m[32m            FROM raw.api_responses r[m
[32m+[m[32m            JOIN core.fixtures f ON f.id = (r.requested_params->>'fixture')::bigint[m
[32m+[m[32m            WHERE r.endpoint = %s[m
[32m+[m[32m              AND f.league_id = %s[m
[32m+[m[32m              AND f.season = %s[m
[32m+[m[32m            """,[m
[32m+[m[32m            (str(endpoint), int(league_id), int(season)),[m
[32m+[m[32m        )[m
[32m+[m[32m        if isinstance(v, datetime):[m
[32m+[m[32m            if v.tzinfo is None:[m
[32m+[m[32m                return v.replace(tzinfo=timezone.utc)[m
[32m+[m[32m            return v.astimezone(timezone.utc)[m
[32m+[m[32m        return None[m
[32m+[m
     def _query_raw_count_24h(self, league_id: int, season: int) -> int:[m
         return int([m
             query_scalar([m
[1mdiff --git a/src/mcp/queries.py b/src/mcp/queries.py[m
[1mindex 0f27ae3..9726119 100644[m
[1m--- a/src/mcp/queries.py[m
[1m+++ b/src/mcp/queries.py[m
[36m@@ -145,6 +145,11 @@[m [mDATABASE_STATS_QUERY = """[m
       (SELECT COUNT(*) FROM core.venues) AS core_venues,[m
       (SELECT COUNT(*) FROM core.fixtures) AS core_fixtures,[m
       (SELECT COUNT(*) FROM core.fixture_details) AS core_fixture_details,[m
[32m+[m[32m      (SELECT COUNT(*) FROM core.injuries) AS core_injuries,[m
[32m+[m[32m      (SELECT COUNT(*) FROM core.fixture_players) AS core_fixture_players,[m
[32m+[m[32m      (SELECT COUNT(*) FROM core.fixture_events) AS core_fixture_events,[m
[32m+[m[32m      (SELECT COUNT(*) FROM core.fixture_statistics) AS core_fixture_statistics,[m
[32m+[m[32m      (SELECT COUNT(*) FROM core.fixture_lineups) AS core_fixture_lineups,[m
       (SELECT COUNT(*) FROM core.standings) AS core_standings,[m
       (SELECT MAX(fetched_at) FROM raw.api_responses) AS raw_last_fetched_at,[m
       (SELECT MAX(updated_at) FROM core.fixtures) AS core_fixtures_last_updated_at[m
